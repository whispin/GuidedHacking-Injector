name: Build GH Injector Library and GUI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-library:
    runs-on: windows-latest

    strategy:
      matrix:
        configuration: [Release]
        platform: [x86, x64]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup VS Dev Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.platform }}

    - name: Build Library Solution
      run: |
        # Try building projects individually for x86 to isolate issues
        if ("${{ matrix.platform }}" -eq "x86") {
          echo "Building GH Injector Library project..."
          msbuild "GH Injector Library\GH Injector Library.vcxproj" /p:Configuration=${{ matrix.configuration }} /p:Platform=Win32 /p:WholeProgramOptimization=false /p:TreatWarningAsError=false
          
          echo "Building GH Injector DNP project..."
          msbuild "GH Injector DNP\GH Injector DNP.vcxproj" /p:Configuration=${{ matrix.configuration }} /p:Platform=Win32 /p:WholeProgramOptimization=false /p:TreatWarningAsError=false
          
          echo "Building GH Injector SM project..."
          msbuild "GH Injector SM\GH Injector SM\GH Injector SM.vcxproj" /p:Configuration=${{ matrix.configuration }} /p:Platform=Win32 /p:WholeProgramOptimization=false /p:TreatWarningAsError=false
        } else {
          msbuild "GH Injector Library.sln" /p:Configuration=${{ matrix.configuration }} /p:Platform=${{ matrix.platform }} /m
        }

    - name: List library build output
      run: |
        echo "Listing library build output directories:"
        Get-ChildItem -Recurse -Include "*.dll","*.exe" | Select-Object FullName

    - name: Prepare library artifacts
      run: |
        $platformDir = "${{ matrix.platform }}"
        $configDir = "${{ matrix.configuration }}"
        
        # Create artifact directory
        mkdir -Force "library-artifacts"
        
        # Define build output directories to search
        $searchPaths = @()
        if ("${{ matrix.platform }}" -eq "x86") {
          $searchPaths += "GH Injector Library\Win32\${{ matrix.configuration }}"
          $searchPaths += "GH Injector DNP\Win32\${{ matrix.configuration }}"
          $searchPaths += "GH Injector SM\GH Injector SM\Win32\${{ matrix.configuration }}"
          $searchPaths += "Win32\${{ matrix.configuration }}"
        } else {
          $searchPaths += "GH Injector Library\x64\${{ matrix.configuration }}"
          $searchPaths += "GH Injector DNP\x64\${{ matrix.configuration }}"
          $searchPaths += "GH Injector SM\GH Injector SM\x64\${{ matrix.configuration }}"
          $searchPaths += "x64\${{ matrix.configuration }}"
        }
        
        # Track copied files to avoid duplicates
        $copiedFiles = @{}
        
        # Search in specific build output directories
        foreach ($searchPath in $searchPaths) {
          if (Test-Path $searchPath) {
            echo "Searching in: $searchPath"
            Get-ChildItem -Path $searchPath -Include "*.dll","*.exe" -File | ForEach-Object {
              $fileName = $_.Name
              $fullPath = $_.FullName
              
              # Skip if we already copied this file name
              if (-not $copiedFiles.ContainsKey($fileName)) {
                echo "Found: $fullPath"
                Copy-Item $fullPath "library-artifacts\" -Force
                $copiedFiles[$fileName] = $true
              } else {
                echo "Skipping duplicate: $fullPath"
              }
            }
          }
        }
        
        # Fallback: search for any remaining files not in library-artifacts
        Get-ChildItem -Recurse -Include "*.dll","*.exe" -File | Where-Object {
          $_.DirectoryName -notlike "*library-artifacts*" -and
          ($_.DirectoryName -like "*Release*" -or $_.DirectoryName -like "*Debug*")
        } | ForEach-Object {
          $fileName = $_.Name
          $fullPath = $_.FullName
          
          # Skip if we already copied this file name
          if (-not $copiedFiles.ContainsKey($fileName)) {
            echo "Found additional: $fullPath"
            Copy-Item $fullPath "library-artifacts\" -Force
            $copiedFiles[$fileName] = $true
          }
        }
        
        echo "Library artifacts directory contents:"
        Get-ChildItem "library-artifacts" | Select-Object Name

    - name: Upload Library Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: GH-Injector-Library-${{ matrix.configuration }}-${{ matrix.platform }}
        path: library-artifacts/
        if-no-files-found: warn

  build-gui:
    runs-on: windows-latest
    needs: build-library

    strategy:
      matrix:
        configuration: [Release, Static]
        platform: [x86, x64]
        exclude:
          - configuration: Static
            platform: x86

    steps:
    - name: Checkout GUI repository
      uses: actions/checkout@v4
      with:
        repository: guided-hacking/GH-Injector-GUI
        path: gui

    - name: Checkout Library repository
      uses: actions/checkout@v4
      with:
        path: library

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup VS Dev Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.platform }}

    - name: Verify build environment
      run: |
        echo "=== Build Environment Information ==="
        echo "MSBuild version:"
        msbuild -version
        echo ""
        echo "Available .NET Framework versions:"
        Get-ChildItem "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework" -Directory -ErrorAction SilentlyContinue | Select-Object Name
        echo ""
        echo "Visual Studio components:"
        Get-ChildItem "C:\Program Files*\Microsoft Visual Studio\*\*\MSBuild" -Directory -ErrorAction SilentlyContinue | Select-Object FullName

    - name: Setup NuGet
      uses: nuget/setup-nuget@v2
      with:
        nuget-version: 'latest'

    - name: Install Qt 5.15.2
      uses: jurplel/install-qt-action@v3
      with:
        version: '5.15.2'
        host: 'windows'
        target: 'desktop'
        arch: ${{ matrix.platform == 'x86' && 'win32_msvc2019' || 'win64_msvc2019_64' }}
        modules: 'qtcharts qtdatavis3d'
        cache: true

    - name: Download and setup static Qt build (Static x64 only)
      if: matrix.configuration == 'Static'
      run: |
        echo "Downloading static Qt build..."
        $url = "https://github.com/martinrotter/qt5-minimalistic-builds/releases/download/5.15.2/qt-5.15.2-static-msvc2019-x86_64.7z"
        $output = "qt-static.7z"
        Invoke-WebRequest -Uri $url -OutFile $output
        
        echo "Extracting static Qt build..."
        7z x $output -o"C:\Qt\5.15.2\"
        
        $staticQtPath = "C:\Qt\5.15.2\qt-5.15.2-static-msvc2019-x86_64"
        echo "Static Qt extracted to $staticQtPath"
        
        # Verify extraction
        if (Test-Path $staticQtPath) {
          echo "Static Qt build extracted successfully"
          echo "Contents of static Qt directory:"
          Get-ChildItem $staticQtPath | Select-Object Name
          
          # Check for required directories
          $requiredDirs = @("include", "lib", "bin")
          foreach ($dir in $requiredDirs) {
            $dirPath = Join-Path $staticQtPath $dir
            if (Test-Path $dirPath) {
              echo "[OK] $dir directory found"
            } else {
              echo "[ERROR] $dir directory not found"
            }
          }
          
          # List Qt modules in include directory
          $includeDir = Join-Path $staticQtPath "include"
          if (Test-Path $includeDir) {
            echo "Available Qt modules in include:"
            Get-ChildItem $includeDir -Directory | Where-Object { $_.Name -like "Qt*" } | Select-Object Name
          }
        } else {
          echo "Error: Static Qt build extraction failed"
          echo "Available directories in C:\Qt\5.15.2\:"
          Get-ChildItem "C:\Qt\5.15.2\" -Directory -ErrorAction SilentlyContinue | Select-Object Name
        }

    - name: Download library artifacts
      uses: actions/download-artifact@v4
      with:
        name: GH-Injector-Library-${{ matrix.configuration == 'Static' && 'Release' || matrix.configuration }}-${{ matrix.platform }}
        path: library-binaries

    - name: Fix .NET target framework
      working-directory: gui
      run: |
        echo "Checking .NET project target framework..."
        if (Test-Path "GH .NET Parser\GH .NET Parser.csproj") {
          echo "Current .NET Parser project content:"
          Get-Content "GH .NET Parser\GH .NET Parser.csproj" | Select-Object -First 10
          
          # Update target framework from net7.0 to net8.0 if needed
          $content = Get-Content "GH .NET Parser\GH .NET Parser.csproj" -Raw
          if ($content -match "net7\.0") {
            echo "Updating target framework from net7.0 to net8.0..."
            $content = $content -replace "net7\.0", "net8.0"
            Set-Content "GH .NET Parser\GH .NET Parser.csproj" -Value $content
            echo "Updated project file:"
            Get-Content "GH .NET Parser\GH .NET Parser.csproj" | Select-Object -First 10
          }
        }

    - name: Restore NuGet packages
      working-directory: gui
      run: |
        echo "Restoring NuGet packages for .NET projects..."
        if (Test-Path "GH .NET Parser\GH .NET Parser.csproj") {
          echo "Restoring packages for GH .NET Parser..."
          dotnet restore "GH .NET Parser\GH .NET Parser.csproj"
        }
        
        echo "Restoring packages for entire solution..."
        nuget restore "GH Injector GUI.sln"

    - name: Setup Qt environment variables
      run: |
        if ("${{ matrix.configuration }}" -eq "Static") {
          $qtPath = "C:\Qt\5.15.2\qt-5.15.2-static-msvc2019-x86_64"
          echo "Using static Qt path: $qtPath"
        } else {
          $qtPath = $env:Qt5_Dir
          echo "Using dynamic Qt path: $qtPath"
        }
        
        if (Test-Path $qtPath) {
          # Set all Qt environment variables
          echo "Qt5_DIR=$qtPath" >> $env:GITHUB_ENV
          echo "CMAKE_PREFIX_PATH=$qtPath" >> $env:GITHUB_ENV
          echo "QTDIR=$qtPath" >> $env:GITHUB_ENV
          echo "QT_DIR=$qtPath" >> $env:GITHUB_ENV
          echo "Qt5Core_DIR=$qtPath\lib\cmake\Qt5Core" >> $env:GITHUB_ENV
          echo "Qt5Gui_DIR=$qtPath\lib\cmake\Qt5Gui" >> $env:GITHUB_ENV
          echo "Qt5Widgets_DIR=$qtPath\lib\cmake\Qt5Widgets" >> $env:GITHUB_ENV
          echo "$qtPath\bin" >> $env:GITHUB_PATH
          
          # Set MSBuild-specific Qt environment variables
          echo "QT_INSTALL_PREFIX=$qtPath" >> $env:GITHUB_ENV
          echo "QT_INSTALL_BINS=$qtPath\bin" >> $env:GITHUB_ENV
          echo "QT_INSTALL_INCLUDES=$qtPath\include" >> $env:GITHUB_ENV
          echo "QT_INSTALL_LIBS=$qtPath\lib" >> $env:GITHUB_ENV
          echo "QT_INSTALL_PLUGINS=$qtPath\plugins" >> $env:GITHUB_ENV
          echo "QT_PLUGIN_PATH=$qtPath\plugins" >> $env:GITHUB_ENV
          echo "QT_QPA_PLATFORM_PLUGIN_PATH=$qtPath\plugins\platforms" >> $env:GITHUB_ENV
          
          # Additional environment variables for static builds
          if ("${{ matrix.configuration }}" -eq "Static") {
            echo "QT_STATIC_BUILD=1" >> $env:GITHUB_ENV
          }
          
          echo "Qt environment configured successfully"
          echo "Qt include path: $qtPath\include"
          echo "Qt lib path: $qtPath\lib"
          echo "Qt bin path: $qtPath\bin"
        } else {
          echo "Error: Qt path not found: $qtPath"
          echo "Available Qt installations:"
          Get-ChildItem "C:\Qt" -Directory -ErrorAction SilentlyContinue | Select-Object FullName
          exit 1
        }

    - name: Verify Qt installation and configure projects
      working-directory: gui
      run: |
        echo "=== Qt Installation Verification ==="
        echo "QTDIR: $env:QTDIR"
        echo "Qt5_Dir: $env:Qt5_Dir"
        echo ""
        
        $qtPath = $env:QTDIR
        if ($qtPath -and (Test-Path $qtPath)) {
          echo "Qt installation found at: $qtPath"
          
          # Verify Qt include directory and QApplication header
          $includeDir = "$qtPath\include"
          if (Test-Path $includeDir) {
            echo "Qt include directory found: $includeDir"
            
            # Check for QApplication header specifically
            $qAppHeader = "$includeDir\QtWidgets\QApplication"
            if (Test-Path $qAppHeader) {
              echo "[OK] QApplication header found at: $qAppHeader"
            } else {
              echo "[WARNING] QApplication header not found, checking alternative locations..."
              # Check for qapplication.h
              $qAppHeaderAlt = "$includeDir\QtWidgets\qapplication.h"
              if (Test-Path $qAppHeaderAlt) {
                echo "[OK] qapplication.h found at: $qAppHeaderAlt"
              } else {
                echo "[ERROR] QApplication header not found in QtWidgets"
                echo "Available headers in QtWidgets:"
                if (Test-Path "$includeDir\QtWidgets") {
                  Get-ChildItem "$includeDir\QtWidgets" | Select-Object Name | Format-Table -AutoSize
                }
              }
            }
            
            echo "Available Qt modules:"
            Get-ChildItem $includeDir -Directory | Where-Object { $_.Name -like "Qt*" } | Select-Object Name
          } else {
            echo "[ERROR] Qt include directory not found: $includeDir"
          }
          
          # Verify Qt lib directory
          $libDir = "$qtPath\lib"
          if (Test-Path $libDir) {
            echo "Qt lib directory found: $libDir"
            echo "Available Qt libraries:"
            Get-ChildItem $libDir -Include "Qt*.lib" | Select-Object Name
          } else {
            echo "[ERROR] Qt lib directory not found: $libDir"
          }
          
          # Create a comprehensive Qt props file for MSBuild
          $propsContent = '<?xml version="1.0" encoding="utf-8"?>' + "`n"
          $propsContent += '<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">' + "`n"
          $propsContent += '  <PropertyGroup>' + "`n"
          $propsContent += "    <QtInstall>$qtPath</QtInstall>" + "`n"
          $propsContent += "    <QtToolsPath>$qtPath\bin</QtToolsPath>" + "`n"
          $propsContent += "    <QtIncludePath>$qtPath\include</QtIncludePath>" + "`n"
          $propsContent += "    <QtLibraryPath>$qtPath\lib</QtLibraryPath>" + "`n"
          $propsContent += "    <QTDIR>$qtPath</QTDIR>" + "`n"
          $propsContent += "    <QtUicPath>$qtPath\bin\uic.exe</QtUicPath>" + "`n"
          $propsContent += "    <QtMocPath>$qtPath\bin\moc.exe</QtMocPath>" + "`n"
          $propsContent += "    <QtRccPath>$qtPath\bin\rcc.exe</QtRccPath>" + "`n"
          $propsContent += '  </PropertyGroup>' + "`n"
          $propsContent += '  <ItemDefinitionGroup>' + "`n"
          $propsContent += '    <ClCompile>' + "`n"
          $propsContent += "      <AdditionalIncludeDirectories>$qtPath\include;$qtPath\include\QtCore;$qtPath\include\QtGui;$qtPath\include\QtWidgets;$qtPath\include\QtNetwork;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>" + "`n"
          $propsContent += '      <PreprocessorDefinitions>QT_WIDGETS_LIB;QT_GUI_LIB;QT_CORE_LIB;QT_NETWORK_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>' + "`n"
          $propsContent += '    </ClCompile>' + "`n"
          $propsContent += '    <Link>' + "`n"
          $propsContent += "      <AdditionalLibraryDirectories>$qtPath\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>" + "`n"
          $propsContent += '    </Link>' + "`n"
          $propsContent += '  </ItemDefinitionGroup>' + "`n"
          $propsContent += '</Project>'
          
          Set-Content "qt-custom.props" -Value $propsContent
          echo "Created custom Qt props file: qt-custom.props"
          
          # Find and modify all .vcxproj files to import our Qt props
          echo ""
          echo "=== Configuring Qt Projects ==="
          $vcxprojFiles = Get-ChildItem -Recurse -Include "*.vcxproj" | Where-Object { 
            $content = Get-Content $_.FullName -Raw
            $content -match "Qt" -or $content -match "QApplication" -or $_.Name -like "*GUI*"
          }
          
          foreach ($project in $vcxprojFiles) {
            echo "Configuring Qt project: $($project.Name)"
            $projectContent = Get-Content $project.FullName -Raw
            
            # Check if our props file is already imported (more thorough check)
            if ($projectContent -notmatch "qt-custom\.props") {
              # Find a safe location to add the Import - after the first PropertyGroup but before any ItemGroup or Target
              $safeImportLocation = $false
              
              # Try to find the end of the first PropertyGroup
              $propertyGroupEndPattern = '</PropertyGroup>'
              if ($projectContent -match $propertyGroupEndPattern) {
                $qtImport = "`n  " + '<Import Project="$(MSBuildProjectDirectory)\..\qt-custom.props" Condition="Exists(''$(MSBuildProjectDirectory)\..\qt-custom.props'')" />'
                $projectContent = $projectContent -replace $propertyGroupEndPattern, ($propertyGroupEndPattern + $qtImport), 1
                $safeImportLocation = $true
              }
              
              # If that didn't work, try to find before the first ItemGroup
              if (-not $safeImportLocation) {
                $itemGroupPattern = '(\s*<ItemGroup[^>]*>)'
                if ($projectContent -match $itemGroupPattern) {
                  $qtImport = '  <Import Project="$(MSBuildProjectDirectory)\..\qt-custom.props" Condition="Exists(''$(MSBuildProjectDirectory)\..\qt-custom.props'')" />' + "`n"
                  $projectContent = $projectContent -replace $itemGroupPattern, ($qtImport + '$1'), 1
                  $safeImportLocation = $true
                }
              }
              
              # If that didn't work, try to find before the first Target
              if (-not $safeImportLocation) {
                $targetPattern = '(\s*<Target[^>]*>)'
                if ($projectContent -match $targetPattern) {
                  $qtImport = '  <Import Project="$(MSBuildProjectDirectory)\..\qt-custom.props" Condition="Exists(''$(MSBuildProjectDirectory)\..\qt-custom.props'')" />' + "`n"
                  $projectContent = $projectContent -replace $targetPattern, ($qtImport + '$1'), 1
                  $safeImportLocation = $true
                }
              }
              
              if ($safeImportLocation) {
                # Validate the modified project file before saving
                try {
                  $xmlDoc = [xml]$projectContent
                  Set-Content $project.FullName -Value $projectContent
                  echo "  Added Qt props import to $($project.Name) - XML validation passed"
                } catch {
                  echo "  ERROR: XML validation failed for $($project.Name): $($_.Exception.Message)"
                  echo "  Skipping Qt props import for this project"
                }
              } else {
                echo "  Could not find safe location for Import element in $($project.Name)"
              }
            } else {
              echo "  Qt props already imported in $($project.Name)"
            }
          }
        } else {
          echo "Qt installation not found or QTDIR not set"
          exit 1
        }

    - name: Copy library binaries to GUI project
      run: |
        echo "Copying library binaries to GUI project..."
        if (Test-Path "library-binaries") {
          Copy-Item "library-binaries\*" "gui\" -Recurse -Force
          echo "Library binaries copied successfully"
        } else {
          echo "Warning: Library binaries not found"
        }

    - name: Generate Qt UI headers
      working-directory: gui
      run: |
        echo "=== Generating Qt UI Headers ==="
        
        # Find all .ui files in the project
        $uiFiles = Get-ChildItem -Recurse -Include "*.ui"
        
        if ($uiFiles.Count -eq 0) {
          echo "No .ui files found in the project"
        } else {
          echo "Found $($uiFiles.Count) .ui files:"
          foreach ($uiFile in $uiFiles) {
            echo "  $($uiFile.FullName)"
          }
          
          # Set up UIC tool path
          $uicPath = "$env:QTDIR\bin\uic.exe"
          if (-not (Test-Path $uicPath)) {
            echo "ERROR: UIC tool not found at $uicPath"
            echo "Available files in Qt bin directory:"
            Get-ChildItem "$env:QTDIR\bin" | Select-Object Name
            exit 1
          }
          
          echo "Using UIC tool: $uicPath"
          
          # Generate UI headers
          foreach ($uiFile in $uiFiles) {
            $uiFileName = $uiFile.BaseName
            $uiDir = $uiFile.Directory.FullName
            $headerFileName = "ui_$uiFileName.h"
            $headerPath = Join-Path $uiDir $headerFileName
            
            echo "Generating $headerFileName from $($uiFile.Name)..."
            
            try {
              & $uicPath $uiFile.FullName -o $headerPath
              if ($LASTEXITCODE -eq 0) {
                echo "  [OK] Generated $headerPath"
              } else {
                echo "  [ERROR] Failed to generate $headerPath (exit code: $LASTEXITCODE)"
              }
            } catch {
              echo "  [ERROR] Exception generating $headerPath : $($_.Exception.Message)"
            }
          }
          
          # Verify generated headers
          echo ""
          echo "Verifying generated UI headers:"
          foreach ($uiFile in $uiFiles) {
            $uiFileName = $uiFile.BaseName
            $uiDir = $uiFile.Directory.FullName
            $headerFileName = "ui_$uiFileName.h"
            $headerPath = Join-Path $uiDir $headerFileName
            
            if (Test-Path $headerPath) {
              echo "  [OK] $headerFileName exists"
            } else {
              echo "  [MISSING] $headerFileName not found"
            }
          }
        }

    - name: Generate Qt MOC files
      working-directory: gui
      run: |
        echo "=== Generating Qt MOC Files ==="
        
        # Find all header files that might need MOC processing
        $headerFiles = Get-ChildItem -Recurse -Include "*.h" | Where-Object {
          $content = Get-Content $_.FullName -Raw -ErrorAction SilentlyContinue
          $content -match "Q_OBJECT" -or $content -match "Q_GADGET" -or $content -match "Q_NAMESPACE"
        }
        
        if ($headerFiles.Count -eq 0) {
          echo "No header files requiring MOC processing found"
        } else {
          echo "Found $($headerFiles.Count) header files that may need MOC processing:"
          foreach ($headerFile in $headerFiles) {
            echo "  $($headerFile.FullName)"
          }
          
          # Set up MOC tool path
          $mocTool = "$env:QTDIR\bin\moc.exe"
          if (-not (Test-Path $mocTool)) {
            echo "ERROR: MOC tool not found at $mocTool"
            echo "Available files in Qt bin directory:"
            Get-ChildItem "$env:QTDIR\bin" | Select-Object Name
            exit 1
          }
          
          echo "Using MOC tool: $mocTool"
          
          # Generate MOC files
          foreach ($headerFile in $headerFiles) {
            $headerFileName = $headerFile.BaseName
            $headerDir = $headerFile.Directory.FullName
            $mocFileName = "moc_$headerFileName.cpp"
            $mocPath_output = Join-Path $headerDir $mocFileName
            
            echo "Generating $mocFileName from $($headerFile.Name)..."
            
            try {
              $mocArgs = @(
                $headerFile.FullName
                "-o"
                $mocPath_output
                "-I$env:QTDIR\include"
                "-I$env:QTDIR\include\QtCore"
                "-I$env:QTDIR\include\QtGui"
                "-I$env:QTDIR\include\QtWidgets"
                "-I$env:QTDIR\include\QtNetwork"
              )
              
              & $mocTool @mocArgs
              if ($LASTEXITCODE -eq 0) {
                echo "  [OK] Generated $mocPath_output"
              } else {
                echo "  [WARNING] Failed to generate $mocPath_output (exit code: $LASTEXITCODE) - may not be needed"
              }
            } catch {
              echo "  [WARNING] Exception generating $mocPath_output : $($_.Exception.Message) - may not be needed"
            }
          }
        }

    - name: Validate project files
      working-directory: gui
      run: |
        echo "=== Validating Project Files ==="
        
        $allValid = $true
        $vcxprojFiles = Get-ChildItem -Recurse -Include "*.vcxproj"
        
        foreach ($project in $vcxprojFiles) {
          echo "Validating: $($project.Name)"
          try {
            $content = Get-Content $project.FullName -Raw
            $xmlDoc = [xml]$content
            echo "  [OK] $($project.Name) - XML is valid"
            
            # Additional MSBuild-specific validation
            # Check for ItemGroup elements outside of Target elements
            $itemGroupsOutsideTargets = $xmlDoc.SelectNodes("//ItemGroup[not(ancestor::Target)]")
            foreach ($itemGroup in $itemGroupsOutsideTargets) {
              $hasValidOperation = $false
              foreach ($child in $itemGroup.ChildNodes) {
                if ($child.NodeType -eq "Element") {
                  $operation = $child.GetAttribute("Include") + $child.GetAttribute("Update") + $child.GetAttribute("Remove")
                  if ($operation -ne "") {
                    $hasValidOperation = $true
                    break
                  }
                }
              }
              if (-not $hasValidOperation -and $itemGroup.ChildNodes.Count -gt 0) {
                echo "  [WARNING] $($project.Name) - ItemGroup outside Target may have missing Include/Update/Remove operations"
                $allValid = $false
              }
            }
            
          } catch {
            echo "  [ERROR] $($project.Name) - XML validation failed: $($_.Exception.Message)"
            $allValid = $false
            
            # Show the problematic content around the error
            $lines = Get-Content $project.FullName
            $errorLine = if ($_.Exception.Message -match "line (\d+)") { [int]$matches[1] } else { 1 }
            $startLine = [Math]::Max(1, $errorLine - 5)
            $endLine = [Math]::Min($lines.Length, $errorLine + 5)
            
            echo "    Content around line $errorLine :"
            for ($i = $startLine; $i -le $endLine; $i++) {
              $marker = if ($i -eq $errorLine) { " >>> " } else { "     " }
              echo "$marker$i : $($lines[$i-1])"
            }
          }
        }
        
        if (-not $allValid) {
          echo ""
          echo "ERROR: Some project files have XML validation errors. Build may fail."
          echo "Please check the errors above and fix the project files."
        } else {
          echo ""
          echo "All project files passed XML validation."
        }

    - name: Debug pch.h and Qt includes
      working-directory: gui
      run: |
        echo "=== Debugging pch.h and Qt includes ==="
        
        # Find pch.h files
        $pchFiles = Get-ChildItem -Recurse -Include "pch.h"
        foreach ($pchFile in $pchFiles) {
          echo "Found pch.h: $($pchFile.FullName)"
          echo "Content around line 45:"
          $lines = Get-Content $pchFile.FullName
          $startLine = [Math]::Max(0, 40)
          $endLine = [Math]::Min($lines.Length - 1, 50)
          for ($i = $startLine; $i -le $endLine; $i++) {
            $lineNum = $i + 1
            $marker = if ($lineNum -eq 45) { " >>> " } else { "     " }
            echo "$marker$lineNum : $($lines[$i])"
          }
          echo ""
        }
        
        # Check if QApplication can be found
        echo "=== Checking QApplication availability ==="
        $qtIncludeDir = "$env:QTDIR\include"
        echo "Qt include directory: $qtIncludeDir"
        
        if (Test-Path "$qtIncludeDir\QtWidgets") {
          echo "QtWidgets directory exists"
          echo "Contents of QtWidgets:"
          Get-ChildItem "$qtIncludeDir\QtWidgets" | Select-Object Name | Format-Table -AutoSize
          
          # Check for QApplication specifically
          $qappPaths = @(
            "$qtIncludeDir\QtWidgets\QApplication",
            "$qtIncludeDir\QtWidgets\qapplication.h",
            "$qtIncludeDir\QApplication",
            "$qtIncludeDir\qapplication.h"
          )
          
          foreach ($path in $qappPaths) {
            if (Test-Path $path) {
              echo "[FOUND] QApplication at: $path"
            } else {
              echo "[NOT FOUND] $path"
            }
          }
        } else {
          echo "QtWidgets directory does not exist!"
        }

    - name: Build GUI Solution
      working-directory: gui
      run: |
        $platform = "${{ matrix.platform }}"
        $config = "${{ matrix.configuration }}"
        $msbuildPlatform = $platform
        
        echo "=== GUI Build Information ==="
        echo "Matrix Configuration: ${{ matrix.configuration }}"
        echo "Matrix Platform: ${{ matrix.platform }}"
        echo "Resolved Configuration: $config"
        echo "Resolved Platform: $msbuildPlatform"
        echo "Qt Directory: $env:QTDIR"
        echo ""
        
        echo "Available solution files:"
        Get-ChildItem "*.sln" | Select-Object Name
        echo ""
        
        echo "Checking solution configurations..."
        $solutionFile = "GH Injector GUI.sln"
        if (Test-Path $solutionFile) {
          echo "Solution file exists: $solutionFile"
          echo ""
          echo "Available solution configurations:"
          Get-Content $solutionFile | Where-Object { $_ -match "^\s*(Debug|Release|Static)\|" } | ForEach-Object { $_.Trim() }
          echo ""
          echo "Looking for target configuration: $config|$msbuildPlatform"
          $targetConfig = "$config|$msbuildPlatform"
          $configExists = Get-Content $solutionFile | Where-Object { $_ -match [regex]::Escape($targetConfig) }
          if ($configExists) {
            echo "Target configuration found in solution"
          } else {
            echo "Target configuration NOT found in solution"
            echo "Available configurations containing '$config':"
            Get-Content $solutionFile | Where-Object { $_ -match $config } | ForEach-Object { $_.Trim() }
          }
        } else {
          echo "Solution file not found: $solutionFile"
          echo "Available files:"
          Get-ChildItem | Select-Object Name
        }
        
        echo ""
        echo "Building GUI solution with: Configuration=$config, Platform=$msbuildPlatform"
        
        # Add comprehensive MSBuild properties for Qt
        $qtIncludePaths = "$env:QTDIR\include;$env:QTDIR\include\QtCore;$env:QTDIR\include\QtGui;$env:QTDIR\include\QtWidgets;$env:QTDIR\include\QtNetwork"
        $qtLibPaths = "$env:QTDIR\lib"
        
        $additionalProps = @(
          "/p:QTDIR=`"$env:QTDIR`""
          "/p:QT_INSTALL_PREFIX=`"$env:QTDIR`""
          "/p:QT_INSTALL_INCLUDES=`"$env:QTDIR\include`""
          "/p:QT_INSTALL_LIBS=`"$env:QTDIR\lib`""
          "/p:QtInstall=`"$env:QTDIR`""
          "/p:QtIncludePath=`"$env:QTDIR\include`""
          "/p:QtLibraryPath=`"$env:QTDIR\lib`""
          "/p:QtToolsPath=`"$env:QTDIR\bin`""
          "/p:QtUicPath=`"$env:QTDIR\bin\uic.exe`""
          "/p:QtMocPath=`"$env:QTDIR\bin\moc.exe`""
          "/p:QtRccPath=`"$env:QTDIR\bin\rcc.exe`""
          "/p:AdditionalIncludeDirectories=`"$qtIncludePaths`""
          "/p:AdditionalLibraryDirectories=`"$qtLibPaths`""
        )
        
        if ("$config" -eq "Static") {
          $additionalProps += "/p:QT_STATIC_BUILD=true"
        }
        
        echo "MSBuild properties:"
        $additionalProps | ForEach-Object { echo "  $_" }
        
        # Build with normal output but comprehensive Qt properties
        echo ""
        echo "Starting MSBuild..."
        
        # First try to validate the solution file
        try {
          echo "Validating solution file..."
          $solutionContent = Get-Content $solutionFile -Raw
          if ($solutionContent -match "Microsoft Visual Studio Solution File") {
            echo "Solution file appears to be valid"
          } else {
            echo "WARNING: Solution file may be corrupted"
          }
        } catch {
          echo "WARNING: Could not validate solution file: $($_.Exception.Message)"
        }
        
        # Build with error handling
        $buildResult = $null
        try {
          msbuild $solutionFile /p:Configuration=$config /p:Platform=$msbuildPlatform /p:WholeProgramOptimization=false /p:TreatWarningAsError=false $additionalProps /m /verbosity:normal
          $buildResult = $LASTEXITCODE
        } catch {
          echo "MSBuild execution failed: $($_.Exception.Message)"
          $buildResult = 1
        }
        
        if ($buildResult -ne 0) {
          echo ""
          echo "Build failed with exit code: $buildResult"
          echo "Attempting to diagnose the issue..."
          
          # Check if any project files have issues
          echo "Checking project files for common issues..."
          $vcxprojFiles = Get-ChildItem -Recurse -Include "*.vcxproj"
          foreach ($project in $vcxprojFiles) {
            $content = Get-Content $project.FullName -Raw
            if ($content -match '<[^>]+\s+[^>]*>') {
              # Check for common MSBuild issues
              if ($content -match '<\s*[^>]*\s+[^=]*=\s*[^>]*>') {
                echo "Potential syntax issue in $($project.Name)"
              }
            }
          }
          
          exit $buildResult
        } else {
          echo "Build completed successfully"
        }

    - name: List GUI build output
      working-directory: gui
      run: |
        echo "Listing GUI build output:"
        Get-ChildItem -Recurse -Include "*.exe","*.dll" | Select-Object FullName

    - name: Prepare GUI artifacts
      working-directory: gui
      run: |
        $platform = "${{ matrix.platform }}"
        $config = "${{ matrix.configuration }}"
        
        # Create artifact directory
        mkdir -Force "gui-artifacts"
        
        # Define build output directories to search
        $searchPaths = @()
        if ($platform -eq "x86") {
          # GUI solution uses x86 naming, not Win32
          $searchPaths += "GH Injector GUI\x86\$config"
          $searchPaths += "GH Injector\x86\$config"
          $searchPaths += "x86\$config"
          # Also check Win32 as fallback
          $searchPaths += "GH Injector GUI\Win32\$config"
          $searchPaths += "GH Injector\Win32\$config"
          $searchPaths += "Win32\$config"
        } else {
          $searchPaths += "GH Injector GUI\x64\$config"
          $searchPaths += "GH Injector\x64\$config"
          $searchPaths += "x64\$config"
        }
        
        # Track copied files to avoid duplicates
        $copiedFiles = @{}
        
        # Search in specific build output directories
        foreach ($searchPath in $searchPaths) {
          if (Test-Path $searchPath) {
            echo "Searching GUI files in: $searchPath"
            Get-ChildItem -Path $searchPath -Include "*.exe","*.dll" -File | ForEach-Object {
              $fileName = $_.Name
              $fullPath = $_.FullName
              
              # Skip if we already copied this file name
              if (-not $copiedFiles.ContainsKey($fileName)) {
                echo "Found GUI file: $fullPath"
                Copy-Item $fullPath "gui-artifacts\" -Force
                $copiedFiles[$fileName] = $true
              } else {
                echo "Skipping duplicate GUI file: $fullPath"
              }
            }
          }
        }
        
        # Fallback: search for any remaining GUI files not in gui-artifacts
        Get-ChildItem -Recurse -Include "*.exe","*.dll" -File | Where-Object {
          $_.DirectoryName -notlike "*gui-artifacts*" -and
          ($_.DirectoryName -like "*$config*" -or $_.DirectoryName -like "*Release*" -or $_.DirectoryName -like "*Debug*")
        } | ForEach-Object {
          $fileName = $_.Name
          $fullPath = $_.FullName
          
          # Skip if we already copied this file name
          if (-not $copiedFiles.ContainsKey($fileName)) {
            echo "Found additional GUI file: $fullPath"
            Copy-Item $fullPath "gui-artifacts\" -Force
            $copiedFiles[$fileName] = $true
          }
        }
        
        # Copy Qt DLLs for non-static builds
        if ("$config" -ne "Static") {
          echo "Copying Qt runtime DLLs..."
          $qtBinPath = "$env:QTDIR\bin"
          if (Test-Path $qtBinPath) {
            $qtDlls = @("Qt5Core.dll", "Qt5Gui.dll", "Qt5Widgets.dll", "Qt5Network.dll")
            foreach ($dll in $qtDlls) {
              $dllPath = Join-Path $qtBinPath $dll
              if (Test-Path $dllPath) {
                $dllFileName = Split-Path $dllPath -Leaf
                if (-not $copiedFiles.ContainsKey($dllFileName)) {
                  Copy-Item $dllPath "gui-artifacts\" -Force
                  echo "Copied Qt DLL: $dll"
                  $copiedFiles[$dllFileName] = $true
                }
              }
            }
          }
        }
        
        echo "GUI artifacts directory contents:"
        Get-ChildItem "gui-artifacts" | Select-Object Name

    - name: Upload GUI Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: GH-Injector-GUI-${{ matrix.configuration }}-${{ matrix.platform }}
        path: gui/gui-artifacts/
        if-no-files-found: warn

  package:
    needs: [build-library, build-gui]
    runs-on: windows-latest
    if: success()

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4

    - name: Create complete release package
      run: |
        mkdir release-package
        
        # Create platform directories
        mkdir "release-package/x86"
        mkdir "release-package/x64"
        
        # Copy library files
        if (Test-Path "GH-Injector-Library-Release-x86") {
          Copy-Item "GH-Injector-Library-Release-x86/*" "release-package/x86/" -Recurse -Force
        }
        if (Test-Path "GH-Injector-Library-Release-x64") {
          Copy-Item "GH-Injector-Library-Release-x64/*" "release-package/x64/" -Recurse -Force
        }
        
        # Copy GUI files (Release builds)
        if (Test-Path "GH-Injector-GUI-Release-x86") {
          Copy-Item "GH-Injector-GUI-Release-x86/*" "release-package/x86/" -Recurse -Force
        }
        if (Test-Path "GH-Injector-GUI-Release-x64") {
          Copy-Item "GH-Injector-GUI-Release-x64/*" "release-package/x64/" -Recurse -Force
        }
        
        # Copy static GUI builds (standalone executables - x64 only)
        if (Test-Path "GH-Injector-GUI-Static-x64") {
          mkdir "release-package/x64-static"
          Copy-Item "GH-Injector-GUI-Static-x64/*" "release-package/x64-static/" -Recurse -Force
        }
        
        echo "Complete package structure:"
        Get-ChildItem "release-package" -Recurse | Select-Object FullName

    - name: Upload Complete Package
      uses: actions/upload-artifact@v4
      with:
        name: GH-Injector-Complete-Package
        path: release-package/
        if-no-files-found: error